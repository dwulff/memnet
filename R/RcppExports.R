# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

seed <- function(n, m) {
    .Call('memnet_seed', PACKAGE = 'memnet', n, m)
}

sm <- function(x) {
    .Call('memnet_sm', PACKAGE = 'memnet', x)
}

getdegrees <- function(adj, pos) {
    .Call('memnet_getdegrees', PACKAGE = 'memnet', adj, pos)
}

getnonneighbors <- function(adj, node) {
    .Call('memnet_getnonneighbors', PACKAGE = 'memnet', adj, node)
}

selectnode <- function(ps) {
    .Call('memnet_selectnode', PACKAGE = 'memnet', ps)
}

stgame <- function(n, m) {
    .Call('memnet_stgame', PACKAGE = 'memnet', n, m)
}

emptyseed <- function(n) {
    .Call('memnet_emptyseed', PACKAGE = 'memnet', n)
}

puni <- function() {
    .Call('memnet_puni', PACKAGE = 'memnet')
}

unconnectedneighbor <- function(adj, from, to) {
    .Call('memnet_unconnectedneighbor', PACKAGE = 'memnet', adj, from, to)
}

test <- function(n = 100L, m = 5L) {
    invisible(.Call('memnet_test', PACKAGE = 'memnet', n, m))
}

hkgame <- function(n, m, p) {
    .Call('memnet_hkgame', PACKAGE = 'memnet', n, m, p)
}

set <- function(v) {
    .Call('memnet_set', PACKAGE = 'memnet', v)
}

mset <- function(dat) {
    .Call('memnet_mset', PACKAGE = 'memnet', dat)
}

indx <- function(s, set) {
    .Call('memnet_indx', PACKAGE = 'memnet', s, set)
}

lags <- function(dat, l) {
    .Call('memnet_lags', PACKAGE = 'memnet', dat, l)
}

strsplit <- function(s, delim) {
    .Call('memnet_strsplit', PACKAGE = 'memnet', s, delim)
}

getinds <- function(pairs, unis) {
    .Call('memnet_getinds', PACKAGE = 'memnet', pairs, unis)
}

getpairs <- function(spairs, del) {
    .Call('memnet_getpairs', PACKAGE = 'memnet', spairs, del)
}

count <- function(v) {
    .Call('memnet_count', PACKAGE = 'memnet', v)
}

mcount <- function(dat) {
    .Call('memnet_mcount', PACKAGE = 'memnet', dat)
}

getprob <- function(counts, N) {
    .Call('memnet_getprob', PACKAGE = 'memnet', counts, N)
}

pinwin <- function(n, l) {
    .Call('memnet_pinwin', PACKAGE = 'memnet', n, l)
}

mpinwin <- function(ns, l) {
    .Call('memnet_mpinwin', PACKAGE = 'memnet', ns, l)
}

lens <- function(dat) {
    .Call('memnet_lens', PACKAGE = 'memnet', dat)
}

mlength <- function(dat) {
    .Call('memnet_mlength', PACKAGE = 'memnet', dat)
}

getplink <- function(inds, probs, pinwin) {
    .Call('memnet_getplink', PACKAGE = 'memnet', inds, probs, pinwin)
}

dbinom <- function(k, n, p) {
    .Call('memnet_dbinom', PACKAGE = 'memnet', k, n, p)
}

pbinom <- function(k, n, p) {
    .Call('memnet_pbinom', PACKAGE = 'memnet', k, n, p)
}

#' Create Goni graph
#'
#' Creare Goni graph from verbal fluency data. Function creates a graph
#' by adding edges for words that occur within a window size \code{l}
#' more frequently than \code{min_cooc} and \code{100(1-crit)%} of
#' chance productions.
#'
#'
#' @param dat
#' @param l an integer specifying the window size. The internal upper limit
#'   of \code{l} is the number of productions.
#' @param crit a numeric within \code{[0,1]} specifiying the type-1 error
#'   rate of including an edge between unconnected words.
#' @param min_cooc integer specifying the minimum number of times two words
#'   have to coocur within a window size of \code{l} to consider including
#'   an edge between them.
#'
#' @return
#' A matrix
#'
goni_graph <- function(dat, l = 3L, min_cooc = 1L, crit = .05) {
    .Call('memnet_goni_graph', PACKAGE = 'memnet', dat, l, min_cooc, crit)
}

#' Create random walk graph
#'
#' Creare random walk graph from verbal fluency data. Function creates a graph
#' by adding edges for words that occur within a window size of 1.
#'
#' @param dat
#'
#' @return
#' A matrix
#'
rw_graph <- function(dat) {
    .Call('memnet_rw_graph', PACKAGE = 'memnet', dat)
}

unique_int <- function(v) {
    .Call('memnet_unique_int', PACKAGE = 'memnet', v)
}

rint <- function(n) {
    .Call('memnet_rint', PACKAGE = 'memnet', n)
}

runi <- function() {
    .Call('memnet_runi', PACKAGE = 'memnet')
}

#' Get adjacency list
#'
#' Get list containing adjacent vertices for each vertex in the graph.
#'
#' Adjacent vertices are returned in terms of their row index of the adjacency matrix.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#'
#' @return A list of vectors containing the indices of adjacent vertices.
#'
#' @export
get_adjlist <- function(adj) {
    .Call('memnet_get_adjlist', PACKAGE = 'memnet', adj)
}

#' Get neighbors k or fewer steps away
#'
#' Function iterates over graph to identify for a given vertex all vertices that are
#' no more than k steps apart.
#'
#' k = 0 will return be interpreted as k = 1.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#' @param start integer specifying the row of the start vertex in the adjacency matrix.
#' @param k integer specifying the maximum distance to the start vertex.
#'
#' @return A character vector containing vertices \code{k} or fewer steps away
#' from \code{start}.
#'
#' @export
get_neighborhood <- function(adj, start, k) {
    .Call('memnet_get_neighborhood', PACKAGE = 'memnet', adj, start, k)
}

#' Get vector of neighbors exactly k steps away
#'
#' Function iterates over graph to identify for a given vertex all vertices that are
#' exactly k steps apart.
#'
#' k = 0 will return be interpreted as k = 1.
#'
#' @param adj numeric matrix specifying the adjacency matrix.
#' @param start integer specifying the row of the start vertex in the adjacency matrix.
#' @param k integer specifying the exact distance to the start vertex.
#'
#' @return A character vector containing vertices \code{k} or fewer steps away
#' from \code{start}.
#'
#' @export
get_kneighbor <- function(adj, start, k) {
    .Call('memnet_get_kneighbor', PACKAGE = 'memnet', adj, start, k)
}

tostring <- function(items) {
    .Call('memnet_tostring', PACKAGE = 'memnet', items)
}

m_nn <- function(ele, set, rep) {
    .Call('memnet_m_nn', PACKAGE = 'memnet', ele, set, rep)
}

m_nc <- function(ele, set, rep) {
    .Call('memnet_m_nc', PACKAGE = 'memnet', ele, set, rep)
}

m_cn <- function(ele, set, rep) {
    .Call('memnet_m_cn', PACKAGE = 'memnet', ele, set, rep)
}

m_cc <- function(ele, set, rep) {
    .Call('memnet_m_cc', PACKAGE = 'memnet', ele, set, rep)
}

match_nn <- function(elems, set, rep) {
    .Call('memnet_match_nn', PACKAGE = 'memnet', elems, set, rep)
}

match_nc <- function(elems, set, rep) {
    .Call('memnet_match_nc', PACKAGE = 'memnet', elems, set, rep)
}

match_cn <- function(elems, set, rep) {
    .Call('memnet_match_cn', PACKAGE = 'memnet', elems, set, rep)
}

match_cc <- function(elems, set, rep) {
    .Call('memnet_match_cc', PACKAGE = 'memnet', elems, set, rep)
}

noverk <- function(n, k) {
    .Call('memnet_noverk', PACKAGE = 'memnet', n, k)
}

getneighbors <- function(adjlist, pos) {
    .Call('memnet_getneighbors', PACKAGE = 'memnet', adjlist, pos)
}

getnext <- function(neighbors) {
    .Call('memnet_getnext', PACKAGE = 'memnet', neighbors)
}

unicut <- function(vs, n) {
    .Call('memnet_unicut', PACKAGE = 'memnet', vs, n)
}

#' Verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting a neighbor with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. Where the random walk process enters
#' the network and where it jumps to is additionally controlled
#' by \code{type}. Neighbors are always selected uniformly.
#'
#' @param adjlist a list containing row indices for adjacent vertices as created
#'   by \link{get_adjlist}.
#' @param n integer specifying the number of productions.
#' @param pjump numeric specifying the probability of a jump.
#' @param type integer controlling network start and jump vertices.
#'   For \code{type = 0} the process selects the start vertex and any jump
#'   vertices proportional to their degree. For \code{type = 1} the process
#'   selects a random vertex to serve as the start vertex and the jump vertex.
#'   For \code{type = 2} the process selects the start and any jump vertices
#'   uniformly.
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
fluency <- function(adjlist, n, pjump, type) {
    .Call('memnet_fluency', PACKAGE = 'memnet', adjlist, n, pjump, type)
}

#' Verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{fluency}.
#'
#' For details see \link{fluency}.
#'
#' @inheritParams fluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mfluency <- function(adjlist, n, pjump = 0, type = 1L) {
    .Call('memnet_mfluency', PACKAGE = 'memnet', adjlist, n, pjump, type)
}

#' Fast verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
ffluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('memnet_ffluency', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Fast verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{fluency}.
#'
#' For details see \link{ffluency}.
#'
#' @inheritParams ffluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mfsearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('memnet_mfsearch', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Exhaustive verbal fluency generator
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
efluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('memnet_efluency', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{efluency}.
#'
#' For details see \link{efluency}.
#'
#' @inheritParams efluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mesearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('memnet_mesearch', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Verbal fluency step counter
#'
#' Generates verbal fluency data using a switcher-random walk process.
#'
#' Function produces verbal fluency data via a switcher random walk
#' process that traverses the network by selecting neighbors with
#' probability 1-\code{pjump} or jumps to a random place in the network
#' with probability \code{pjump}. How the random walk process enters
#' the network and how it jumps to is additionally controlled
#' by \code{random}. Neighbors are always selected uniformly.
#'
#' In contrast to \link{fluency}, does not check at every step whether
#' the sampled neighbor is already in the list of productions. Instead
#' \code{ffluency} simply returns the list of unique productions. This means
#' that if repetitions occur \code{ffluency} will produce sequences of length
#' \code{min(n*3 - k, n)} where k is the number of repeptitions.
#'
#' @inheritParams fluency
#' @param n integer specifying the number of productions.
#' @param random bool controlling jump vertices.
#'   For \code{random = TRUE} the process selects jump at random. For
#'   \code{random = FALSE} the process always jumps back to the start vertex. The
#'   start vertex is always selected at random.
#'
#'
#' @return Integer vector containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
sfluency <- function(adjlist, n, pjump, random, pref_start = FALSE) {
    .Call('memnet_sfluency', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Exhaustive verbal fluency generator wrapper
#'
#' Generates multiple verbal fluency sequences using \code{efluency}.
#'
#' For details see \link{efluency}.
#'
#' @inheritParams efluency
#'
#' @return List of character vectors containing the indices of the fluency productions.
#'   Indices refer to the row of the item in the original adjacency matrix. See
#'   \link{get_adjlist}.
#'
#' @export
mssearch <- function(adjlist, n, pjump = 0, random = FALSE, pref_start = FALSE) {
    .Call('memnet_mssearch', PACKAGE = 'memnet', adjlist, n, pjump, random, pref_start)
}

#' Random walk
#'
#' Traverses a network using a switcher-random walk process and records the earliest
#' visit to vertices of interest.
#'
#' Beginning at a given start vertext, function traverses a network using switcher
#' random walk and records for each of a list of vertices of interest the index at which
#' the respective vertices have been visited first.
#'
#' If a vertex specified in \code{observe} has never been visited then the function
#' returns \code{nmax} for that vertex.
#'
#' @inheritParams fluency
#' @param start index of the start vertix.
#' @param observe integer vector specifying the vertices whose first visits should be recorded.
#' @param nmax integer specifying the maximum number of steps.
#'
#' @return Numeric, 3 column matrix containing in each row the start vertex, the end vertex, and
#' the (minimum) number of steps it took to reach the end vertext from the start vertex.
#'
#' @export
rwalk <- function(adjlist, start, observe, nmax = 1000L, pjump = 0) {
    .Call('memnet_rwalk', PACKAGE = 'memnet', adjlist, start, observe, nmax, pjump)
}

#' Random walk
#'
#' Traverses a network using a switcher-random walk process and records the earliest
#' visit to vertices of interest.
#'
#' Beginning at a given start vertext, function traverses a network using switcher
#' random walk and records for each of a list of vertices of interest the index at which
#' the respective vertices have been visited first.
#'
#' If a vertex specified in \code{observe} has never been visited then the function
#' returns \code{nmax} for that vertex.
#'
#' @inheritParams fluency
#' @param start index of the start vertix.
#' @param observe integer vector specifying the vertices whose first visits should be recorded.
#' @param nmax integer specifying the maximum number of steps.
#'
#' @return Numeric, 3 column matrix containing in each row the start vertex, the end vertex, and
#' the (minimum) number of steps it took to reach the end vertext from the start vertex.
#'
#' @export
mrwalk <- function(adjlist, start, observe, nrep = 100L, aggregate = TRUE, nmax = 1000L, pjump = 0) {
    .Call('memnet_mrwalk', PACKAGE = 'memnet', adjlist, start, observe, nrep, aggregate, nmax, pjump)
}

staSearch <- function(x) {
    .Call('memnet_staSearch', PACKAGE = 'memnet', x)
}

dynSearch <- function(x) {
    .Call('memnet_dynSearch', PACKAGE = 'memnet', x)
}

notInVector <- function(item, set) {
    .Call('memnet_notInVector', PACKAGE = 'memnet', item, set)
}

staSearch2 <- function(x) {
    .Call('memnet_staSearch2', PACKAGE = 'memnet', x)
}

